# GO 语言实战

> [Go语言实战](https://book.douban.com/subject/27015617/)
>
> 作者: [威廉·肯尼迪 (William Kennedy)](https://book.douban.com/search/威廉·肯尼迪) / [布赖恩·克特森 (Brian Ketelsen)](https://book.douban.com/search/布赖恩·克特森) / [埃里克·圣马丁 (Erik St.Martin)](https://book.douban.com/search/埃里克·圣马丁) 
>
> 出版社: 人民邮电出版社
>
> 译者: [李兆海](https://book.douban.com/search/李兆海) 
>
> 出版年: 2017-3-1
>
> 页数: 224
>
> 定价: CNY 59.00
>
> 装帧: 平装
>
> ISBN: 9787115445353

## 相关资源

- [GO 入门指南](https://github.com/Unknwon/the-way-to-go_ZH_CN)
- [Go语言高级编程](https://chai2010.cn/advanced-go-programming-book/)
- [Go语言圣经（中文版）](https://docs.hacknode.org/gopl-zh/)
- [Go语言四十二章经](https://github.com/ffhelicopter/Go42)
- [Build web application with Golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md)


## 工具链

### 包

* 每个包都在一个单 独的目录里。不能把多个包放到同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。 这意味着，同一个目录下的所有.go 文件必须声明同一个包名。
* 给包及其目录命名 时，应该使用简洁、清晰且全小写的名字，这有利于开发时频繁输入包名。
* 所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。

### 导入

* 标准库中的包会在安装 Go 的位置找到。Go 开发者创建的包会在 GOPATH 环境变量指定的目录里查找。 GOPATH 指定的这些目录就是开发者的个人工作空间。
* 编译器会首先查找 Go 的安装目录，然后才会按顺序查找 GOPATH 变量里列出的目录。
* 重名的包可以通过命名导入来导入。命名导入是指，在 import 语句给出的包路径的左侧定义一个名字，将导入的包命名为新名字。
* 用户可能需要导入一个包，但是不需要引用这个包的标识符。在这种情况，可以使用空白标识符 `_ ` 来重命名这个导入。

### 函数 init 

* 所有被编译器发现的 init 函数都会安排在 main 函数之前执行。 init 函数用在设置包、初始化变量或者其他要在程序运行前优先完成的引导工作。

### GO 工具包

* `go build`
* `go clean`
* `go get -u`
* `go env`
* `go vet`
* `go fmt` fmt 命令会 自动格式化开发人员指定的源代码文件并保存。
* `godoc -http=:6060` 通知 godoc 在端口 6060 启动 Web 服务器。

## 数组、切片和映射

### 数组

* 数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。
* 一旦声明，数组里存储的数据类型和数组长度就都不能改变了。
* 数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能互相赋值。
* 在函数之间传递变量时， 总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复制，并传递给函数。可以只传入指向数组的指针，以如果改变指针指向的值， 会改变共享的内存。

### 切片

* 切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。
* 切片的动态增长是通过内置函数 append 来实现的。这个函数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。
* 因为切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。
* 切片有 3 个字段 的数据结构，这些数据结构包含 Go 语言需要操作底层数组的元数据。这 3 个字段分别是指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素个数（即容量）。
* `slice := make([]string, 5)` 如果只指定长度，那么切片的容量和长度相等。
* `slice := make([]int, 3, 5)` 分别指定长度和容量时，创建的切片，底层数组的长度是指定的容量，但是初始化后并不能访问所有的数组元素。
* 使用切片字面量创建切片。这种方法和创建 数组类似，只是不需要指定 [] 运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定。
* `var slice []int` 创建 `nil` 切片
* `slice := []int{}` 创建空切片，空切片在底层数组包含 0 个元素，也没有分配任何存储空间。
* 对底层数组容量是 k 的切片 `slice[i:j]` 来说，长度: `j - i` ，容量: `k - i`
* 共享同一个底层数组的切片，如果一个切片修改了该底层数组的共享部分，另一个切片也能感知到。
* 函数 append 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25% 的容量。
* 在 64 位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量字段分别需要 8 字节。由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。

### 映射

* 映射是一个集合，可以使用类似处理数组和切片的方式迭代映射中的元素。
* 映射是无序的集合，意味着没有办法预测键值对被返回的顺序。
* `dict := make(map[string]int)` 使用 make 创建映射
* `dict := map[string]string{"Red": "#da1337", "Orange": "#e95a22"}` 使用映射字面量
* 映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值 可以使用 == 运算符做比较。切片、函数以及包含切片的结构类型这些类型由于具有引用语义， 不能作为映射的键。
* 迭代映射里的所有值和迭代数组或切片一样，使用关键字 `range`。
* 如果想把一个键值对从映射里删除，就使用内置的 `delete` 函数。
* 在函数间传递映射并不会制造出该映射的一个副本。当传递映射给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。

## 类型系统

### 用户自定义类型

* 声明以关键字 type 开始，之后是新类型的名字，最后是关键字 struct 。
* 创建一个变量并初始化为其零值，习惯是使用关键字 var 。如果变量被初始化为某个非零值，就配合结构字面量和短变量声明操作符`:=`来创建变量。

```go
// user 在程序里定义一个用户类型
type user struct {
  name    string
  Emali   string
}
```

* 另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明。如：`type Duration int64`

### 方法

* 关键字 func 和函数名之间的参数被称作**接收者**，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称为方法。
* Go 语言里有两种类型的接收者：值接收者和指针接收者。如果使用值接收者声明方法，调用时会使用这个值的一个副本来执行，而指针接受者使用实际值来调用方法。

### 类型的本质

* 内置类型是由语言提供的一组类型，分别是数值类型、字符串类型 和布尔类型。
* 引用类型有如下几个：切片、映射、通道、接口和函数类型。

### 接口

* 接口是用来定义行为的类型。
* 接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫作 iTable，包含了所存储的值的类型信息。iTable 包含了已存储的值的类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。将类型信息和指针组合在一起，就将这两个值组成了一种特殊的关系。
* 如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。

**备注：** 方法集规则

```txt
Values       Methods Receivers
-----------------------------------------------
T            *T
(t T)        (t T) and (t *T)

// 从接收者类型的角度来看方法集
Methods Receivers      Values
-----------------------------------------------
(t T)                  (t *T)
T and *T               *T
```

### 嵌入类型

* 嵌入类型是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型。
* 由于内部类型的提升，内部类型实现的接口会自动提升到外部类型。这意味着由于内部类型的实现，外部类型也同样实现了这个接口。
* 如果外部类型实现了相同的方法，内部类型的实现就不会被提升。不过内部类型的值一直存在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。

### 公开或未公开标识符

* 当一个标识符的名字以**小写字母开头**时，这个标识符就是未公开的，即包外的代码不可见。 如果一个标识符以**大写字母开头**，这个标识符就是公开的，即被包外的代码可见。
* 即便内部类型是未公开的，内部类型里声明的字段依旧是公开的。既然内部类型的标识符提升到了外部类型，这些公开的字段也可以通过外部类型的字段的值来访问。

## 并发

Go 语言的并发同步模型来自一个叫作通信顺序进程（Communicating Sequential Processes，CSP） 的范型（paradigm）。CSP 是一种消息传递模型，通过在 goroutine 之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。用于在 goroutine 之间同步和传递数据的关键数据类型叫作通道 （channel）。

### 并发与并行

* 并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。在很多情况下，并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。

### goroutine

* WaitGroup 是一个计数信号量，可以用来记录并维护运行的 goroutine 。如果 WaitGroup 的值大于 0 ， Wait 方法 就会阻塞。
* 当 goroutine 占用时间过长时， 调度器会停止当前正运行的 goroutine，并给其他可运行的 goroutine 运行的机会。
* Go 标准库的 runtime 包里有一个名为 `GOMAXPROCS` 的函数， 通过它可以指定调度器可用的逻辑处理器的数量。

```go
go func() {
  // ...
}() // 匿名函数
```

### 竞争状态

* 如果两个或者多个 goroutine 在没有互相同步的情况下，访问某个共享的资源，并试图同时读和写这个资源，就处于相互竞争的状态，这种情况被称作**竞争状态（race candition）**。
* `go build -race` 用竞争检测器标志来编译程序

### 锁住共享资源

* 原子函数能够以很底层的加锁机制来同步访问整型变量和指针。
* atmoic 包的`AddInt64 ` 函数会同步整型值的加法，`LoadInt64` 和 `StoreInt64` 这两个函数提供了一种安全地读和写一个整型值的方式。
* 另一种同步访问共享资源的方式是使用互斥锁（ mutex ）。互斥锁这个名字来自互斥（mutual exclusion）的概念。互斥锁用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以 执行这个临界区代码。
* `var mutex sync.Mutex`用来定义一段代码临界区，  `mutex.Lock()` 同一时刻只允许一个 goroutine 进入临界区，`mutex.Unlock()`释放锁，允许其他正在等待的 goroutine进入临界区

### 通道

* 声明通道时，需要指定将要被共享的数据的类型。可以通过通道**共享**内置类型、命名类型、结构类型和引用类型的值或者指针。
* **无缓冲的通道**（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine **阻塞等待**。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。
* **有缓冲的通道**（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲 区容纳被发送的值时，发送动作才会阻塞。这导致有缓冲的通道和无缓冲的通道之间的一个很大 的不同：**无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证**。

## 并发模式

### runner

* runner 包用于展示如何使用通道来监视程序的执行时间，如果程序运行时间太长，也可以 用 runner 包来终止程序。

### pool

* 这个包用于展示如何使用有缓冲的通道实现资源池，来管理可以在任意数量的goroutine之间共享及独立使用的资源。这种模式在需要共享一组静态资源的情况（如共享数据库连接或者内存缓冲区）下非常有用。

### work

* work 包的目的是展示如何使用无缓冲的通道来创建一个 goroutine 池，这些 goroutine 执行 并控制一组工作，让其并发执行。

## 标准库

### 文档与源代码

* https://golang.org/pkg/
* 标准库的源代码都会安装在$GOROOT/src/pkg 文件夹中。
* 类似 godoc 、 gocode 甚至 go build 这些工具， 都需要读取标准库的源代码才能完成其工作。

### 记录日志

* 标准库的 log 包包含了记录日志需要的所有功能

### 编码解码

* 使用 json 包的 NewDecoder 函数以及 Decode 方法进行解码。
* 使用 json 包的 MarshalIndent 函数进行编码。

### 输入和输出

* io 包是围绕着实现了 io.Writer 和 io.Reader 接口类型的值而构建的。由于 io.Writer 和 io.Reader 提供了足够的抽象，这些 io 包里的函数和方法并不知道数据的类型，也不知道这些数据在物理上是如何读和写的。
* 所有实现了这两个接口的类型的值，都可以使用 io 包提供的所有功能，也可以用于其他包里接受这两个接口的函数以及 方法。这是用接口类型来构造函数和 API 最美妙的地方。

## 测试和性能

### 单元测试

* 正向路经测试，在正常执行的情况 下，保证代码不产生错误的测试。测试负向路径的场景，保证代码不仅会产生错误，而且是预期的错误。

* **基础测试**（basic test）只使用一组参数和结果来测试 一段代码。 **表组测试**（table test）也会测试一段代码，但是会使用多组参数和结果进行测试。也 可以使用一些方法来**模仿（mock）测试**代码需要使用到的外部资源。
* Go 语言的测试工具只会认为以 `_test.go` 结尾的文件是测试文件。如果没有遵从这个约定，在包里 运行 go test 的时候就可能会报告没有测试文件。一旦测试工具找到了测试文件，就会查找里 面的测试函数并执行。
* 一个测试函数 必须是公开的函数，并且以 `Test` 单词开头。不但函数名字要以 Test 开头，而且函数的签名必 须接收一个指向 `testing.T` 类型的`指针`，并且不返回任何值。
* `go test -v` 执行测试

### 基准测试

* 想要测试解决同一问题的不同方案的性能，以及查看 哪种解决方案的性能更好时，基准测试就会很有用。
* 基准测试也可以用来识别某段代码的 CPU 或者内存效率问题，而这段代码的效率可能会严重影响整个应用程序的性能。
* 基准测试的文件名也必须以 ` _test.go` 结尾。 同时也必须导入 `testing` 包。
* 基准测试函数必须以 `Benchmark` 开头，接受一个指向 `testing.B `类型的`指针`作为唯一参数。 为了让基准测试框架能准确测试性能，它必须在一段时间内反复运行这段代码。
* `go test -v -run="none" -bench="BenchmarkXxxx"`  我们给 -run 选项传递了字符串 "none" ，来保证在运行制订的基准测试函数之前没有单元测试会被运行。
* 默认情况下，基准测试的最小运行时间是 1 秒。如果想让运行时间更长，可以使用 `-benchtime` 选项来更改测试执行的最短时间。
* `-benchmem` 选项可以提供每次操作分 配内存的次数，以及总共分配内存的字节数。输出结果中单位为 `allocs/op `的值表示每次操作从堆上分配内存的次数，单位为 `B/op` 的值表示每次操作分配的字节数。
* 有时候，增加基准测试的时间，会得到更加精确的性能结果。对大多数测试来说，超过 3 秒的基准测试并不会改变测试的精确度。只是每次基准测试的结果会稍有不同。

### 示例

* 示例基于已经存在的公开的函数或者方法。我们需要使用 Example 作为函数名的开始。
* `go test -v -run="ExampleXxxx"`   -run 选项接受任意的正则表达式，来过滤要运行的测试函数。这个选项既支持单元测试，也支持示例函数。

---