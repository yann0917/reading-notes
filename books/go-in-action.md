# GO 语言实战

> [Go语言实战](https://book.douban.com/subject/27015617/)
>
> 作者: [威廉·肯尼迪 (William Kennedy)](https://book.douban.com/search/威廉·肯尼迪) / [布赖恩·克特森 (Brian Ketelsen)](https://book.douban.com/search/布赖恩·克特森) / [埃里克·圣马丁 (Erik St.Martin)](https://book.douban.com/search/埃里克·圣马丁) 
> 出版社: 人民邮电出版社
> 译者: [李兆海](https://book.douban.com/search/李兆海) 
> 出版年: 2017-3-1
> 页数: 224
> 定价: CNY 59.00
> 装帧: 平装
> ISBN: 9787115445353

## 相关资源

- [GO 入门指南](https://github.com/Unknwon/the-way-to-go_ZH_CN)
- [Go语言高级编程](https://chai2010.cn/advanced-go-programming-book/)
- [Go语言圣经（中文版）](https://docs.hacknode.org/gopl-zh/)
- [Go语言四十二章经](https://github.com/ffhelicopter/Go42)
- [Build web application with Golang](https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md)


## 工具链

### 包

* 每个包都在一个单 独的目录里。不能把多个包放到同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。 这意味着，同一个目录下的所有.go 文件必须声明同一个包名。
* 给包及其目录命名 时，应该使用简洁、清晰且全小写的名字，这有利于开发时频繁输入包名。
* 所有用 Go 语言编译的可执行程序都必须有一个名叫 main 的包。

### 导入

* 标准库中的包会在安装 Go 的位置找到。Go 开发者创建的包会在 GOPATH 环境变量指定的目录里查找。 GOPATH 指定的这些目录就是开发者的个人工作空间。
* 编译器会首先查找 Go 的安装目录，然后才会按顺序查找 GOPATH 变量里列出的目录。
* 重名的包可以通过命名导入来导入。命名导入是指，在 import 语句给出的包路径的左侧定义一个名字，将导入的包命名为新名字。
* 用户可能需要导入一个包，但是不需要引用这个包的标识符。在这种情况，可以使用空白标识符 `_ ` 来重命名这个导入。

### 函数 init 

* 所有被编译器发现的 init 函数都会安排在 main 函数之前执行。 init 函数用在设置包、初始化变量或者其他要在程序运行前优先完成的引导工作。

### GO 工具包

* `go build`
* `go clean`
* `go get -u`
* `go env`
* `go vet`
* `go fmt` fmt 命令会 自动格式化开发人员指定的源代码文件并保存。
* `godoc -http=:6060` 通知 godoc 在端口 6060 启动 Web 服务器。

## 数组、切片和映射

### 数组

* 数组是一个长度固定的数据类型，用于存储一段具有相同的类型的元素的连续块。数组存储的类型可以是内置类型，如整型或者字符串，也可以是某种结构类型。
* 一旦声明，数组里存储的数据类型和数组长度就都不能改变了。
* 数组变量的类型包括数组长度和每个元素的类型。只有这两部分都相同的数组，才是类型相同的数组，才能互相赋值。
* 在函数之间传递变量时， 总是以值的方式传递的。如果这个变量是一个数组，意味着整个数组，不管有多长，都会完整复制，并传递给函数。可以只传入指向数组的指针，以如果改变指针指向的值， 会改变共享的内存。

### 切片

* 切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。
* 切片的动态增长是通过内置函数 append 来实现的。这个函数可以快速且高效地增长切片。还可以通过对切片再次切片来缩小一个切片的大小。
* 因为切片的底层内存也是在连续块中分配的，所以切片还能获得索引、迭代以及为垃圾回收优化的好处。
* 切片有 3 个字段 的数据结构，这些数据结构包含 Go 语言需要操作底层数组的元数据。这 3 个字段分别是指向底层数组的指针、切片访问的元素的个数（即长度）和切片允许增长到的元素个数（即容量）。
* `slice := make([]string, 5)` 如果只指定长度，那么切片的容量和长度相等。
* `slice := make([]int, 3, 5)` 分别指定长度和容量时，创建的切片，底层数组的长度是指定的容量，但是初始化后并不能访问所有的数组元素。
* 使用切片字面量创建切片。这种方法和创建 数组类似，只是不需要指定 [] 运算符里的值。初始的长度和容量会基于初始化时提供的元素的个数确定。
* `var slice []int` 创建 `nil` 切片
* `slice := []int{}` 创建空切片，空切片在底层数组包含 0 个元素，也没有分配任何存储空间。
* 对底层数组容量是 k 的切片 `slice[i:j]` 来说，长度: `j - i` ，容量: `k - i`
* 共享同一个底层数组的切片，如果一个切片修改了该底层数组的共享部分，另一个切片也能感知到。
* 函数 append 会智能地处理底层数组的容量增长。在切片的容量小于 1000 个元素时，总是会成倍地增加容量。一旦元素个数超过 1000，容量的增长因子会设为 1.25，也就是会每次增加 25% 的容量。
* 在 64 位架构的机器上，一个切片需要 24 字节的内存：指针字段需要 8 字节，长度和容量字段分别需要 8 字节。由于与切片关联的数据包含在底层数组里，不属于切片本身，所以将切片复制到任意函数的时候，对底层数组大小都不会有影响。

### 映射

* 映射是一个集合，可以使用类似处理数组和切片的方式迭代映射中的元素。
* 映射是无序的集合，意味着没有办法预测键值对被返回的顺序。
* `dict := make(map[string]int)` 使用 make 创建映射
* `dict := map[string]string{"Red": "#da1337", "Orange": "#e95a22"}` 使用映射字面量
* 映射的键可以是任何值。这个值的类型可以是内置的类型，也可以是结构类型，只要这个值 可以使用 == 运算符做比较。切片、函数以及包含切片的结构类型这些类型由于具有引用语义， 不能作为映射的键。
* 迭代映射里的所有值和迭代数组或切片一样，使用关键字 `range`。
* 如果想把一个键值对从映射里删除，就使用内置的 `delete` 函数。
* 在函数间传递映射并不会制造出该映射的一个副本。当传递映射给一个函数，并对这个映射做了修改时，所有对这个映射的引用都会察觉到这个修改。

## 类型系统

### 用户自定义类型

* 声明以关键字 type 开始，之后是新类型的名字，最后是关键字 struct 。
* 创建一个变量并初始化为其零值，习惯是使用关键字 var 。如果变量被初始化为某个非零值，就配合结构字面量和短变量声明操作符`:=`来创建变量。

```go
// user 在程序里定义一个用户类型
type user struct {
  name    string
  Emali   string
}
```

* 另一种声明用户定义的类型的方法是，基于一个已有的类型，将其作为新类型的类型说明。如：`type Duration int64`

### 方法

* 关键字 func 和函数名之间的参数被称作**接收者**，将函数与接收者的类型绑在一起。如果一个函数有接收者，这个函数就被称为方法。
* Go 语言里有两种类型的接收者：值接收者和指针接收者。如果使用值接收者声明方法，调用时会使用这个值的一个副本来执行，而指针接受者使用实际值来调用方法。

### 类型的本质

* 内置类型是由语言提供的一组类型，分别是数值类型、字符串类型 和布尔类型。
* 引用类型有如下几个：切片、映射、通道、接口和函数类型。

### 接口

* 接口是用来定义行为的类型。
* 接口值是一个两个字长度的数据结构，第一个字包含一个指向内部表的指针。这个内部表叫作 iTable，包含了所存储的值的类型信息。iTable 包含了已存储的值的类型信息以及与这个值相关联的一组方法。第二个字是一个指向所存储值的指针。将类型信息和指针组合在一起，就将这两个值组成了一种特殊的关系。
* 如果使用指针接收者来实现一个接口，那么只有指向那个类型的指针才能够实现对应的接口。如果使用值接收者来实现一个接口，那么那个类型的值和指针都能够实现对应的接口。

**备注：** 方法集规则

```txt
Values       Methods Receivers
-----------------------------------------------
T            *T
(t T)        (t T) and (t *T)

// 从接收者类型的角度来看方法集
Methods Receivers      Values
-----------------------------------------------
(t T)                  (t *T)
T and *T               *T
```

### 嵌入类型

* 嵌入类型是将已有的类型直接声明在新的结构类型里。被嵌入的类型被称为新的外部类型的内部类型。
* 由于内部类型的提升，内部类型实现的接口会自动提升到外部类型。这意味着由于内部类型的实现，外部类型也同样实现了这个接口。
* 如果外部类型实现了相同的方法，内部类型的实现就不会被提升。不过内部类型的值一直存在，因此还可以通过直接访问内部类型的值，来调用没有被提升的内部类型实现的方法。

### 公开或未公开标识符

* 当一个标识符的名字以小写字母开头时，这个标识符就是未公开的，即包外的代码不可见。 如果一个标识符以大写字母开头，这个标识符就是公开的，即被包外的代码可见。
* 即便内部类型是未公开的，内部类型里声明的字段依旧是公开的。既然内部类型的标识符提升到了外部类型，这些公开的字段也可以通过外部类型的字段的值来访问。

## 并发

Go 语言的并发同步模型来自一个叫作通信顺序进程（Communicating Sequential Processes，CSP） 的范型（paradigm）。CSP 是一种消息传递模型，通过在 goroutine 之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。用于在 goroutine 之间同步和传递数据的关键数据类型叫作通道 （channel）。

### 并发与并行

### goroutine

### 竞争状态

### 锁住共享资源

### 通道

## 并发模式

### runner

### pool

### work



## 标准库

### 文档与源代码

### 记录日志

### 编码解码

### 输入和输出



## 测试和性能

### 单元测试

### 基准测试

### 示例



---